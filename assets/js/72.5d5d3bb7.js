(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{440:function(t,h,v){"use strict";v.r(h);var _=v(11),a=Object(_.a)({},(function(){var t=this,h=t._self._c;return h("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[h("h1",{attrs:{id:"http各版本比较"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#http各版本比较"}},[t._v("#")]),t._v(" http各版本比较")]),t._v(" "),h("p",[t._v("本文主要列出http所经历的5个版本直接比较显著的改变，至于http的详解会在之后有时间再做记录")]),t._v(" "),h("h2",{attrs:{id:"http经历了哪些版本"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#http经历了哪些版本"}},[t._v("#")]),t._v(" http经历了哪些版本？")]),t._v(" "),h("ol",[h("li",[t._v("http0.9")]),t._v(" "),h("li",[t._v("http1.0")]),t._v(" "),h("li",[t._v("http1.1")]),t._v(" "),h("li",[t._v("http2.0")]),t._v(" "),h("li",[t._v("http3.0")])]),t._v(" "),h("h2",{attrs:{id:"http0-9"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#http0-9"}},[t._v("#")]),t._v(" http0.9")]),t._v(" "),h("p",[t._v("http0.9是http最初使用的版本，那时基于tcp/ip的协议的互联网由四部分组成（超文本标记语言/超文本传输协议http0.9，网络浏览器/网络服务器），http0.9就是其中的http协议。")]),t._v(" "),h("p",[t._v("刚诞生之初的http相当简陋，她只支持单向的get方法，并且只能传输文本内容，而文本内容也相对简单，同时不存在请求头和相应之类的概念。")]),t._v(" "),h("h2",{attrs:{id:"http1-0"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#http1-0"}},[t._v("#")]),t._v(" http1.0")]),t._v(" "),h("p",[t._v("http1.0是浏览器和服务器在不断基于实现的需求http进行扩展后在1996年正式发布，从这个版本开始http协议不再只支持简单的超文本标记语言传输，还支持了媒体文件的传输，这位互联网的兴起正式奠定了基础。")]),t._v(" "),h("h3",{attrs:{id:"http1-0相比http0-9多了这些东西"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#http1-0相比http0-9多了这些东西"}},[t._v("#")]),t._v(" http1.0相比http0.9多了这些东西：")]),t._v(" "),h("ol",[h("li",[t._v("在get请求的基础上，新增了post/head请求")]),t._v(" "),h("li",[t._v("新增了请求头，http协议版本号，状态码，缓存，权限等")]),t._v(" "),h("li",[t._v("新增了媒体文件传输（content-type设置为mime type）")])]),t._v(" "),h("p",[h("strong",[t._v("结")]),t._v("：content-type有了text/html和mime type")]),t._v(" "),h("h3",{attrs:{id:"缺点"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),h("p",[t._v("http1.0的请求中每次tcp连接只能发送一个请求，当服务端响应后连接关闭，导致效率低下（这时候还没有keep-alive长连接这种概念）")]),t._v(" "),h("p",[t._v("因为tcp连接只能发送一个请求，所以随着页面的所需请求资源变多网页的性能会越来越差")]),t._v(" "),h("h2",{attrs:{id:"http1-1"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[t._v("#")]),t._v(" http1.1")]),t._v(" "),h("p",[t._v("http1.1首先就解决了我们在1.0中提到的缺点，她允许我们将一个tcp连接设置成持久的，也就说一直保留着三次握手成功的状态，以便于其他请求可以直接使用不经历握手。")]),t._v(" "),h("h3",{attrs:{id:"持久连接的特点"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#持久连接的特点"}},[t._v("#")]),t._v(" 持久连接的特点")]),t._v(" "),h("ol",[h("li",[t._v("因为http1.1中tcp连接默认是不关闭连接的，也就是说不需要我们手动去设置keep-alive。")]),t._v(" "),h("li",[t._v("持久连接的断开条件是客户端和服务端有一方长时间没活动后自动关闭，但相对规范的做法则是在服务端响应客户端最后一个请求时发送"),h("strong",[t._v("Connection：close")]),t._v("，表示要关闭连接。")]),t._v(" "),h("li",[t._v("一般而言，浏览器运行最多同时建立六个持久连接")])]),t._v(" "),h("p",[t._v("除了上诉所说的持久连接，http1.1还引入了管道机制")]),t._v(" "),h("h3",{attrs:{id:"管道机制"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#管道机制"}},[t._v("#")]),t._v(" 管道机制")]),t._v(" "),h("p",[t._v("在以前的tcp请求中，同一个tcp连接中后一个请求会等到前一个发送与响应后才去发起请求，而在管道中他们的请求会被同时发送出去，但响应还是按照顺序来")]),t._v(" "),h("h3",{attrs:{id:"content-length和分块传输编码"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#content-length和分块传输编码"}},[t._v("#")]),t._v(" content-length和分块传输编码")]),t._v(" "),h("p",[t._v("既然一个tcp中能有多个响应了，那么我们要怎么区分数据包对应的响应式哪个，答案就是content-length和分块传输编码了")]),t._v(" "),h("p",[t._v("这里简单说一下，content-length是由服务端响应的，声明本次响应的数据长度，超过这个的就是下一个响应了")]),t._v(" "),h("p",[t._v("至于分块传输编码，是因为content-length的数据长度获取要耗费不少时间，所以就有了分块传输编码。简单说，就是给请求或响应头的信息加上transfer-encoding字段，表明响应将由数量未定的数据块，而这些数据块是以流形式传递（这里不用太纠结，不理解也不影响，因为真要说起来太麻烦了，只给本人记录用）")]),t._v(" "),h("h3",{attrs:{id:"host字段"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#host字段"}},[t._v("#")]),t._v(" Host字段")]),t._v(" "),h("p",[t._v("http1.1新增的请求头host字段，是用来指定主机ip，应用场景主要就是对应虚拟机技术")]),t._v(" "),h("h3",{attrs:{id:"新增请求方式"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#新增请求方式"}},[t._v("#")]),t._v(" 新增请求方式")]),t._v(" "),h("ol",[h("li",[t._v("put")]),t._v(" "),h("li",[t._v("patch")]),t._v(" "),h("li",[t._v("options")]),t._v(" "),h("li",[t._v("delete")])]),t._v(" "),h("h3",{attrs:{id:"仅发送header信息"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#仅发送header信息"}},[t._v("#")]),t._v(" 仅发送header信息")]),t._v(" "),h("p",[t._v("http1.1支持我们只发送header信息，主要作用就是让客户端试探服务端对自己请求的反馈，如果被状态吗为401，那么请求就到此为止，但如果状态码为100（也是http1.1新增的），则表示请求是允许的，重新发一个新的请求，这次带上请求体")]),t._v(" "),h("p",[t._v("总的来说，他即节省了宽带，又确保我们不会发无意义的请求")]),t._v(" "),h("h3",{attrs:{id:"缺点-2"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),h("p",[t._v("tcp连接里可以多个请求，但多个请求是有序的，这样可能会出现网络堵塞的问题。当然了，http1.1允许我们给请求设置优先级，以保证重要的信息先响应，但这并没有解决根本问题。")]),t._v(" "),h("p",[t._v("为了避免上诉问题，http1.1中解决这些问题的方法有减少请求和多开持久连接，不过这些也会带来新的问题，典型的就是我们网页优化的样式/脚本合并，图片嵌入css等等。")]),t._v(" "),h("h2",{attrs:{id:"http2-0"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#http2-0"}},[t._v("#")]),t._v(" http2.0")]),t._v(" "),h("p",[t._v("http2.0解决了上述http1.1的缺点，也就是我们现在常说的"),h("strong",[t._v("全双工模式")]),t._v("，意思是说不仅客户端可以发送多个请求，服务端也可以同时处理多个请求了（多路复用技术取代持久连接），这样一来堵塞问题自然就不存在了")]),t._v(" "),h("p",[t._v("然后，因为http2.0的数据包不再按顺序发送了，所以我们得知道同一个连接里面不同的响应属于哪个请求，为此而生的手段就是给数据进行标记。")]),t._v(" "),h("p",[t._v("在http2.0中，一个请求所包含的所有响应数据包称为一个数据流，每个数据流都有对应唯一的编号，这样一来我们只需要每次响应数据的时候用这个数据流编号进行标记就可以知道哪个响应是哪个请求了。")]),t._v(" "),h("h3",{attrs:{id:"数据流id的规定"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#数据流id的规定"}},[t._v("#")]),t._v(" 数据流id的规定")]),t._v(" "),h("p",[t._v("客户端的数据流id为奇数，服务端的为偶数")]),t._v(" "),h("h3",{attrs:{id:"其他特性"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#其他特性"}},[t._v("#")]),t._v(" 其他特性")]),t._v(" "),h("ol",[h("li",[t._v("http2.0中可以手动取消某次请求，但tcp连接依旧处于打开状态")]),t._v(" "),h("li",[t._v("可以指定数据流优先级，优先级越高响应越快")]),t._v(" "),h("li",[t._v("服务端推送，在不经请求前提下服务端可以自己推送信息给服务端（socket来了！）")]),t._v(" "),h("li",[t._v("http2.0的头信息和数据都是二进制，是一种完全的二进制传输，也叫做帧传输（在之前的版本头信息是文本也就是ascii编码，数据体是文本或二进制），因此 传输速度更快了")]),t._v(" "),h("li",[t._v("对 请求头/响应头这些进行调整，将其变成真正的表（这个我不懂，只是记录一下而已）")])]),t._v(" "),h("h2",{attrs:{id:"http3-0"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#http3-0"}},[t._v("#")]),t._v(" http3.0")]),t._v(" "),h("p",[t._v("对于这个我真的不太了解，因此对此只需要记忆他在udp的基础上实现一个叫做quic的新协议，之后的http请求则是泡在quic协议上，因为基于unp，所以速度飞快，并且听说他完全解决了队头堵塞问题")])])}),[],!1,null,null,null);h.default=a.exports}}]);