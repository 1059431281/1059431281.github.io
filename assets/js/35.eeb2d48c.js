(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{403:function(e,r,t){"use strict";t.r(r);var o=t(11),u=Object(o.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"概论下vue-router实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概论下vue-router实现"}},[e._v("#")]),e._v(" 概论下vue-router实现")]),e._v(" "),r("p",[e._v("执行Vue.use安装router时会向全局混入一个mixin，这个mixin只有一个属性beforeCreate，它的作用是让每个组件拥有"),r("code",[e._v("this.$router")]),e._v("和"),r("code",[e._v("this.$route")]),e._v("属性，执行beforeCreate钩子时会执行router实例的init方法，然后会注册全局组件router-view和router-link。")]),e._v(" "),r("p",[e._v("执行new VueRouter时会将router的配置构建为路由组件映射表，path对应的组件还有name对应的组件，然后内部出初始化一个history属性，有一个History类，又会有三个继承自它的子类，mode的不同histiry实例化的子类不同，这个类有路径跳转transitionTo、push、replace等方法。")]),e._v(" "),r("p",[e._v("注册完毕之后开始执行全局注入的beforeCreate钩子，内部会执行router实例的init方法，内部会执行transitionTo方法，这个方法主要处理三件事，导航守卫的执行，url的变化、和router-view的渲染。首先处理导航守卫，计算出新的路径，然后按照导航执行的顺序将所有的导航放入一个队列里面，例如首先是组件的失活钩子、接下来全局的before钩子和路由更新钩子等，执行内部的runQueue方法，每个钩子的内部需要执行next才会执行下一个导航钩子。")]),e._v(" "),r("p",[e._v("接着是更新url，将现有路径#之后的内容替换成目标fullPath生成一个新的url，然后调用浏览器的pushState，将这条记录压入历史栈。")]),e._v(" "),r("p",[e._v("最后是router-view的渲染，因为router-view存在嵌套使用的原因，所以首先是计算的嵌套的深度，如果一个组件的父组件是由router-view渲染的，深度值就会+1，一个路径会按照从父到子放入matched数组里，从而根据深度值能准确的渲染对应的组件，最后是执行render函数的h方法进行组件的渲染。")]),e._v(" "),r("p",[e._v("本来想用自己的大白话，但想了想关于vue-router的大白话只适合我自己，就用别人的话来放这里让自己记忆复苏用。")]),e._v(" "),r("p",[e._v("无法理解，就看：https://juejin.cn/post/7012272146907037732#heading-13")])])}),[],!1,null,null,null);r.default=u.exports}}]);