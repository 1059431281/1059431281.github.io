(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{440:function(v,_,t){"use strict";t.r(_);var a=t(11),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"https大白话讲解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https大白话讲解"}},[v._v("#")]),v._v(" https大白话讲解")]),v._v(" "),_("h2",{attrs:{id:"先来跑一遍https的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#先来跑一遍https的流程"}},[v._v("#")]),v._v(" 先来跑一遍https的流程")]),v._v(" "),_("ol",[_("li",[v._v("进行传统的tcp三次握手，确实双方的发送和接收能力没有问题")]),v._v(" "),_("li",[v._v("开始进行ssl连接")]),v._v(" "),_("li",[v._v("A：客户端将ssl版本号，加密套件列表，客户端随机数，sessionid，发送给服务端d")]),v._v(" "),_("li",[v._v("B：服务端选择版本，确定要使用的加密套件列表，计算sessionid以及随机发发给客户端")]),v._v(" "),_("li",[v._v("B：服务端发送自己的证书给客户端给客户端（关键）")]),v._v(" "),_("li",[v._v("B：服务端通知客户端消息发送完成")]),v._v(" "),_("li",[v._v("A：客户端验证证")]),v._v(" "),_("li",[v._v("A：客户段生成随机数，并用证书的公钥进行加密发送给服务端")]),v._v(" "),_("li",[v._v("A：通知服务端，之后的消息开启加密")]),v._v(" "),_("li",[v._v("A：客户端协商完成，发送握手验证豹纹确保消息的完整性（利用数字签名）")]),v._v(" "),_("li",[v._v("B：服务端利用自身的证书私钥解密客户端发送来的随机数，后续以此来实现加密传输")]),v._v(" "),_("li",[v._v("B：通知客户端，今后的消息启用加密参数")]),v._v(" "),_("li",[v._v("B：服务端协商完成，发送握手验证豹纹确定消息的完整性")]),v._v(" "),_("li",[v._v("应用数据加密传输（双向）")])]),v._v(" "),_("h2",{attrs:{id:"对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[v._v("#")]),v._v(" 对称加密")]),v._v(" "),_("p",[v._v("**大白话：**通信双方只存在各自的密钥，没有公公钥概念，也就是说通信一方都自己的密钥进行加密，然后另一方用密钥反向解密。")]),v._v(" "),_("p",[v._v("**最好的例子：**传递1，用密钥2加密后1+2变成3，接收方收到后用密钥2解密3-2变成1")]),v._v(" "),_("p",[v._v("**优点：**通信速度速度快，可加密的数据量大")]),v._v(" "),_("p",[v._v("**缺点：**在传递密钥给通信方时由于是明文，容易被人盗取")]),v._v(" "),_("h2",{attrs:{id:"非对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[v._v("#")]),v._v(" 非对称加密")]),v._v(" "),_("p",[v._v("大白话：通信双方有各自的两个密钥，根据加密和解密分为成公钥和私钥。也就是说，通信一方将公钥给对方，而私钥自己保存，以后别人就用公钥加密信息传递给自己，而加密后的数据只能用自己的私钥进行解密")]),v._v(" "),_("h3",{attrs:{id:"非对称加密的两种认证方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密的两种认证方式"}},[v._v("#")]),v._v(" 非对称加密的两种认证方式")]),v._v(" "),_("h4",{attrs:{id:"单向认证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单向认证"}},[v._v("#")]),v._v(" 单向认证")]),v._v(" "),_("h5",{attrs:{id:"第一情况"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一情况"}},[v._v("#")]),v._v(" 第一情况")]),v._v(" "),_("p",[v._v("接收方生成公钥和私钥，把公钥给发送方，之后发送方就用这个公钥给接收方发送数据，而这个数据只有接收方自己的私钥能解，是相对安全的")]),v._v(" "),_("h5",{attrs:{id:"第二种情况"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二种情况"}},[v._v("#")]),v._v(" 第二种情况")]),v._v(" "),_("p",[v._v("发送方生成公钥和私钥，把公钥给接收方a，以后接收方a就可以用公钥解密发送方的数据。但是这有个很明显的缺点，那就这个公钥是透明的，一旦被另一个接收方b获取到了这个公钥，那么接收方b就可很轻易地窃听发送方发给接收方a的数据。")]),v._v(" "),_("h4",{attrs:{id:"双向认证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双向认证"}},[v._v("#")]),v._v(" 双向认证")]),v._v(" "),_("p",[v._v("在单向认证的基础上，接收方也应有自己的公钥和密钥。")]),v._v(" "),_("p",[v._v("比如，发送方发送公钥给对方，接收a也发送自己的公钥给对方，这样一来双方，在通信时就用各自从对方获得的公钥进行加密，然后双方用各自的私钥进行解密，这样就确保了就算公钥被人盗取也不会窃听。")]),v._v(" "),_("p",[v._v("**非堆成加密所需的双向性：**公钥加密，私钥解密；私钥加密，公钥解密；公/私钥加密，公/私钥无法解密")]),v._v(" "),_("p",[v._v("**优点：**安全性max")]),v._v(" "),_("p",[v._v("**缺点：**数据量有限，速度慢")]),v._v(" "),_("h2",{attrs:{id:"数字签名"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数字签名"}},[v._v("#")]),v._v(" 数字签名")]),v._v(" "),_("p",[v._v("数字签名是验证双方身份的一种方式，是消息发送者产生的一段无法伪造的字符串，相当于我们的身份证一样")]),v._v(" "),_("p",[v._v("数字签名是非对称加密和数字摘要技术的组合应用")]),v._v(" "),_("h3",{attrs:{id:"好处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#好处"}},[v._v("#")]),v._v(" 好处")]),v._v(" "),_("ol",[_("li",[v._v("验证数据的来源")]),v._v(" "),_("li",[v._v("验证数据完整性")])]),v._v(" "),_("h3",{attrs:{id:"数字摘要技术-报文摘要"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数字摘要技术-报文摘要"}},[v._v("#")]),v._v(" 数字摘要技术（报文摘要）")]),v._v(" "),_("p",[v._v("简单说，就是将我们的报文进行摘要计算，用的是hash算法（利用实际进行反复进行多次后结果仍旧一次概念）得出摘要。因此，只要哪怕改了一个标点符号都会导致无法变回原来的报文，这便能很好的验证我们的数据完整性。")]),v._v(" "),_("h3",{attrs:{id:"生成数字签名"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生成数字签名"}},[v._v("#")]),v._v(" 生成数字签名")]),v._v(" "),_("p",[v._v("在生成摘要之后，我们可以用发送方的私钥对其进行加密，得到就是我们要的数字签名了。")]),v._v(" "),_("h3",{attrs:{id:"验证数据完整性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#验证数据完整性"}},[v._v("#")]),v._v(" 验证数据完整性")]),v._v(" "),_("ol",[_("li",[v._v("发送方在发送数据时，会把明文转换成数字签名，并把明文传递给对方（这里的明文，可以用公钥进行加密）")]),v._v(" "),_("li",[v._v("接收方拿到明文后进行摘要运算获取摘要，接着再用发送方的公钥对数字签名进行解密获取摘要，对两个摘要进行对比")])]),v._v(" "),_("h3",{attrs:{id:"验证数据来源-身份"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#验证数据来源-身份"}},[v._v("#")]),v._v(" 验证数据来源（身份）")]),v._v(" "),_("p",[v._v("在解密数字签名时，因为只能用发送方的公要进行解密，所以一旦解密成功就说明身份是正确的了")]),v._v(" "),_("h3",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("h4",{attrs:{id:"中间人攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#中间人攻击"}},[v._v("#")]),v._v(" 中间人攻击")]),v._v(" "),_("p",[v._v("中间攻击指的是发送者a和接收者b通信被c给拦截，双方的通信都会经过c，这样一来c就可以获取到b的公钥，利用b的公钥跟a通信。")]),v._v(" "),_("p",[v._v("如果只是发送方折收到c的消息倒也没什么，关键的是c还可以通过假冒a跟b进行通信，这样会造成的后果就是b原本想传送给a的东西全部被盗取。")]),v._v(" "),_("h3",{attrs:{id:"解决方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[v._v("#")]),v._v(" 解决方法")]),v._v(" "),_("p",[v._v("数字证书")]),v._v(" "),_("h2",{attrs:{id:"数字证书"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数字证书"}},[v._v("#")]),v._v(" 数字证书")]),v._v(" "),_("p",[v._v("数字签名的中间人攻击的关键在于我们在网络中的传输会被攻击者修改，但是攻击者其实无法通过网络修改我们本地的信息，也就是说除非电脑中了病毒之类的物理伤害，我们保存在本地的公钥是不会被篡改的。")]),v._v(" "),_("p",[v._v("数字证书也就是我们常说的"),_("strong",[v._v("CA")]),v._v("，它是由权威机构给网站颁发的认可凭证")]),v._v(" "),_("h3",{attrs:{id:"数字证书的内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数字证书的内容"}},[v._v("#")]),v._v(" 数字证书的内容")]),v._v(" "),_("ol",[_("li",[v._v("公钥和私钥")]),v._v(" "),_("li",[v._v("服务端的基本信息（明文，包括签发者id，证书发给谁，有效期，版本号等等）")])]),v._v(" "),_("p",[v._v("因此，服务端发送数据时的包含了"),_("strong",[v._v("原文/数字签名/数字证书")])]),v._v(" "),_("p",[v._v("关于数字证书的其他详细，包括如何签发一个有效证书和服务器如何发送证书的问题这里就不进行深究，下面进行一下总结：")]),v._v(" "),_("ol",[_("li",[v._v("数字证书是安全的，因为他是要权威机构发表的")]),v._v(" "),_("li",[v._v("数字证书的验证会由客户端进行验证，步骤大致是在本地电脑查找是否有服务器证书上的根证书，有则下一步，没则警告")]),v._v(" "),_("li",[v._v("使用根证书的公钥对服务器证书进行解密，得到md1")]),v._v(" "),_("li",[v._v("对证书的内容进行摘要，利用公钥和相应算法再次摘要，得到md2")]),v._v(" "),_("li",[v._v("对比md1和md2，一样则通过认证")])]),v._v(" "),_("h2",{attrs:{id:"关于对称加密和非对称加密的联合使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关于对称加密和非对称加密的联合使用"}},[v._v("#")]),v._v(" 关于对称加密和非对称加密的联合使用")]),v._v(" "),_("p",[v._v("我们知道非对称加密的速度和量都是比较差的，而对称加密则恰恰相反，所以在日常使用中都是将他们进行组合使用，具体来说就是：")]),v._v(" "),_("ol",[_("li",[v._v("客户端生成随机数使用服务器的公钥进行加密发给服务端")]),v._v(" "),_("li",[v._v("服务端用自己的证书私钥进行解密获取随机数（对这里为止是非对称）")]),v._v(" "),_("li",[v._v("使用随机数根客户端进行对称加密进行通信（这里开始之后都是对称）")])]),v._v(" "),_("h2",{attrs:{id:"那么-再来用大白话的方式跑一遍https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#那么-再来用大白话的方式跑一遍https"}},[v._v("#")]),v._v(" 那么，再来用大白话的方式跑一遍https")]),v._v(" "),_("ol",[_("li",[v._v("客户端发起https请求")]),v._v(" "),_("li",[v._v("tcp三次握手")]),v._v(" "),_("li",[v._v("服务端将证书给客户端，证书里面包含了服务端的公钥")]),v._v(" "),_("li",[v._v("客户端对证书进行验证")]),v._v(" "),_("li",[v._v("客户端生成随机并用证书的公钥进行加密传送给服务端")]),v._v(" "),_("li",[v._v("服务端用私钥解密出随机数，用随机数加密与客户端通信")]),v._v(" "),_("li",[v._v("客户端收到回复，也可以用随机数进行加密通信")])]),v._v(" "),_("h2",{attrs:{id:"https的安全可以从那几方面来实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https的安全可以从那几方面来实现"}},[v._v("#")]),v._v(" https的安全可以从那几方面来实现？")]),v._v(" "),_("ol",[_("li",[v._v("数据的完整性")]),v._v(" "),_("li",[v._v("身份的认证")]),v._v(" "),_("li",[v._v("钓鱼网站不复存在")]),v._v(" "),_("li",[v._v("数据的隐秘性")])]),v._v(" "),_("h2",{attrs:{id:"https的缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https的缺点"}},[v._v("#")]),v._v(" https的缺点")]),v._v(" "),_("ol",[_("li",[v._v("速度相比http慢了很多，大概有一半")]),v._v(" "),_("li",[v._v("证书的功能越强大，费用就越高")])]),v._v(" "),_("h2",{attrs:{id:"最后-https就一定是安全的吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最后-https就一定是安全的吗"}},[v._v("#")]),v._v(" 最后，https就一定是安全的吗？")]),v._v(" "),_("p",[v._v("通常来说，https是非常安全，但网络这种东西是没有绝对安全，所以还是存在着攻击手段。")]),v._v(" "),_("p",[v._v("以下几点，有兴趣的话可以去研究：")]),v._v(" "),_("ol",[_("li",[v._v("劫持https的请求，使用arp欺骗")]),v._v(" "),_("li",[v._v("公司有内鬼，在你进行公钥之前进行攻击")]),v._v(" "),_("li",[v._v("伪造，也就是用相似的人名去注册进行欺骗别人")]),v._v(" "),_("li",[v._v("窃取权威认证机构的私钥")]),v._v(" "),_("li",[v._v("想尽办法，在你的本地电脑安装伪造的根证书")])])])}),[],!1,null,null,null);_.default=s.exports}}]);