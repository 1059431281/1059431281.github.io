(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{461:function(t,v,_){"use strict";_.r(v);var e=_(15),i=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),_("p",[t._v("diff算法是基于虚拟dom去实现的，而虚拟dom是一种js对象在，这里不做讲解，那么废话不多说马上开始diff极速版！")]),t._v(" "),_("p",[t._v("首先，diff算法的目的是什么？答案当然是进行最小化的更新，提高我们的页面性能。")]),t._v(" "),_("p",[_("strong",[t._v("题外话")]),t._v("，浏览器自身也是有做大量dom修改时的优化，所以虚拟dom并不是为了diff算法服务的可别误解。")]),t._v(" "),_("h2",{attrs:{id:"diff算法的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#diff算法的流程"}},[t._v("#")]),t._v(" diff算法的流程")]),t._v(" "),_("ol",[_("li",[t._v("数据改变触发setter，setter通过dep触发notify，notify触发了订阅者，订阅者开始执行patch比较")]),t._v(" "),_("li",[t._v("通过patch比较，发现两个元素一样则直接return，不一样则进入下一步")]),t._v(" "),_("li",[t._v("通过patchVnode进行比较，发现新旧内部一样则直接return，不一样则进入下一步")]),t._v(" "),_("li",[t._v("通过patchVnode发现不一样好有四种情况：\n"),_("ol",[_("li",[t._v("新旧vnode内部都是文本节点，直接用新文本替换旧文本")]),t._v(" "),_("li",[t._v("新vnode内部为空，旧不是，直接删除旧内容")]),t._v(" "),_("li",[t._v("新vnode内容不为空，旧不是，直接添加新内容")]),t._v(" "),_("li",[t._v("新旧vnode都有内容且都是节点，进入下一步")])])]),t._v(" "),_("li",[t._v("通过updateChildren对新旧vnode内部进行指针首尾比较，有五种情况：\n"),_("ol",[_("li",[_("p",[t._v("新指针头和旧指针头相等")])]),t._v(" "),_("li",[_("p",[t._v("新指针头和旧指针尾相等")])]),t._v(" "),_("li",[_("p",[t._v("新指针尾和旧指针头相等")])]),t._v(" "),_("li",[_("p",[t._v("新指针尾和旧指针尾相等")])]),t._v(" "),_("li",[_("p",[t._v("以上都不想等，判断新指针头当前所对应的节点在旧中是否存在，存在即进行patchVnode，不存在了直接创建")])]),t._v(" "),_("li",[_("p",[t._v("不是情况，是补充说明，在命中上述某一个条件时会接着去执行patchVnode，以此去循环保证发现所有不同（指针会在每次比较之后超对应方向挪动）")])])])])]),t._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),_("p",[t._v("还是没总结，但这里补充一点，虚拟dom存在的真正意义时为了更好的跨度，进行js对象这种支持性很好。")])])}),[],!1,null,null,null);v.default=i.exports}}]);