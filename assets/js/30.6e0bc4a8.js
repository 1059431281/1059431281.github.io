(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{397:function(t,a,e){"use strict";e.r(a);var r=e(11),c=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("在看这篇文章之前最好是去复习下vue的响应式原理，这样才有助于理解")]),t._v(" "),a("h2",{attrs:{id:"老生常谈-watch和compute的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#老生常谈-watch和compute的区别"}},[t._v("#")]),t._v(" 老生常谈，watch和compute的区别")]),t._v(" "),a("p",[t._v("这里是引出问题，给出最基本的回答，等到看完这篇文章再做新的总结。")]),t._v(" "),a("h3",{attrs:{id:"一、从定义的角度来看两者的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、从定义的角度来看两者的区别"}},[t._v("#")]),t._v(" 一、从定义的角度来看两者的区别")]),t._v(" "),a("p",[t._v("computed的是利用组件中的数据派生出一个新的数据，通常使用函数的方式来定义，不过也可以用对象(包含get和set)的形式来定义。")]),t._v(" "),a("p",[t._v("wacth是监听组件中某个响应式数据的变化并执行对应的函数，又或者说是副作用，并且它没有返回值。")]),t._v(" "),a("h3",{attrs:{id:"二、从使用的角度看两者的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、从使用的角度看两者的区别"}},[t._v("#")]),t._v(" 二、从使用的角度看两者的区别")]),t._v(" "),a("p",[t._v("computed使用的最终目的是对一个或多个组件的数据进行处理，更直接一点说的话就是对页面中一些复杂的表达式进行封装，不那么做的话会导致模版元素变得臃肿不堪。咦？你问为什么不用method实现这个功能？那当然是因为computed是有缓存，而methods没有缓存，computed除非依赖的数据值发生变化都不会重新计算，而methods会就造成了性能问题。")]),t._v(" "),a("p",[t._v("watch使用的最终目的是在依赖的值发生变化时去做一些dom操作或者异步操作，具体来讲的话就是我们可能会在某个数据发生变化的时候去执行接口请求，或是在某个数据发生变化之后将页面恢复为初始状态等等。")]),t._v(" "),a("p",[t._v("最后，能用computed 的地方优先computed")]),t._v(" "),a("p",[t._v("接下来，明白了定义和使用的区别后面我们看看它在实现上有什么区别吧。")]),t._v(" "),a("h2",{attrs:{id:"watch和compute原理的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch和compute原理的区别"}},[t._v("#")]),t._v(" watch和compute原理的区别")]),t._v(" "),a("h3",{attrs:{id:"watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),a("p",[t._v("wach这个其实没有什么好讲，因为它属于vue响应式原理中的watcher，也就是观察者中的一种。")]),t._v(" "),a("p",[t._v("这里说明一下，观察者在内部实现分成了三种，分别为user/render/computed-wachter，我们平时使用的watch是这其中的user-watcher，这里再说明一下，user-watcher在生出的时候会自己触发一次get，将其收集到对应的dep中。")]),t._v(" "),a("h3",{attrs:{id:"computed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),a("p",[t._v("computed是前面提到中的一种，为computed-watcher。他的数据收集方式是这样，他内部会用一些响应数据进行求值，当用到它们时它就会把这个computed-watcher加入到这个响应数据的dep进行管理，这是为了在数据根更新后会重新进行计算，除此之外它还会让这些数据再去绑定render-computed。")]),t._v(" "),a("p",[t._v("此外，为了避免重复计算内部会有一个标识位用来表明已经计算过，而要改变的话就在它们所绑定的computed-watcher会在响应数改变会收到通知，才会去重新进行计算。")]),t._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("无。")]),t._v(" "),a("p",[t._v("其实所谓的总结，只要把上述的三点区别都说出来就好了。")])])}),[],!1,null,null,null);a.default=c.exports}}]);