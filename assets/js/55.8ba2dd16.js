(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{423:function(t,a,v){"use strict";v.r(a);var _=v(11),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("当自己被人问自己某个一知半解的东西时你会怎么样？问答上来还是回答不上来？你是否会觉得自己明明是会的但只是一时想不起来？这归根结底就是你觉得自己会了，但其实还不会，在一知半解的情况下不去专门记忆时肯定不行的，所以才需要才真正认识一下，因为我本人就是如此")]),t._v(" "),a("h2",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("h3",{attrs:{id:"进程是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程是什么"}},[t._v("#")]),t._v(" 进程是什么？")]),t._v(" "),a("p",[t._v("简单说，就是我们程序在一次执行的时候会独自占有的一片内存空间。")]),t._v(" "),a("h3",{attrs:{id:"线程是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程是什么"}},[t._v("#")]),t._v(" 线程是什么？")]),t._v(" "),a("p",[t._v("进程代表一个独立占有的内存空间，那么线程就是它这些内存空间的独立执行单位，是程序执行的一个完整流程（就是程序在进行时去启用进程，然后进程的要实现的东西会由线程完成），通常会是单一线程完成，但也有多线程的情况后面再说。")]),t._v(" "),a("p",[t._v("还有一点，线程是cpu最小的调度单位")]),t._v(" "),a("h2",{attrs:{id:"单线程和多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单线程和多线程"}},[t._v("#")]),t._v(" 单线程和多线程")]),t._v(" "),a("h3",{attrs:{id:"单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单线程"}},[t._v("#")]),t._v(" 单线程")]),t._v(" "),a("p",[t._v("**概念：**一个进程内仅有一个线程，进程的功能全由这一个线程完成")]),t._v(" "),a("p",[t._v("**优点：**顺序式编程，一切的执行都是有序的（js就是单线程运行的，所以才有异步等操作出现）")]),t._v(" "),a("p",[t._v("**缺点：**效率低，因为会因为中间某处执行慢影响后面的执行")]),t._v(" "),a("h3",{attrs:{id:"多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[t._v("#")]),t._v(" 多线程")]),t._v(" "),a("p",[t._v("**概念：**一个进程内有多个线程，进程的功能由这几个线程共同完成")]),t._v(" "),a("p",[t._v("**优点：**效率高，有效提升cpu利用率")]),t._v(" "),a("p",[t._v("**缺点：**创建多线程开销，线程切换开销，死锁与状态同步问题")]),t._v(" "),a("h2",{attrs:{id:"单进程和多进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单进程和多进程"}},[t._v("#")]),t._v(" 单进程和多进程")]),t._v(" "),a("h3",{attrs:{id:"单进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单进程"}},[t._v("#")]),t._v(" 单进程")]),t._v(" "),a("p",[t._v("**概念：**一个应用只可以启用一个实例")]),t._v(" "),a("h3",{attrs:{id:"多进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多进程"}},[t._v("#")]),t._v(" 多进程")]),t._v(" "),a("p",[t._v("**概念：**一个应用可以可以同时启用多个实例")]),t._v(" "),a("h2",{attrs:{id:"浏览器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[t._v("#")]),t._v(" 浏览器")]),t._v(" "),a("p",[t._v("浏览器全都是多线程的，但浏览器有的是多进程有的是多进程，例如ie和火狐是单进程")]),t._v(" "),a("h3",{attrs:{id:"浏览器的进程是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的进程是什么"}},[t._v("#")]),t._v(" 浏览器的进程是什么？")]),t._v(" "),a("p",[t._v("当我们给浏览器打开一个新的空白页就相当于新起了一个渲染进程了。")]),t._v(" "),a("blockquote",[a("p",[t._v("一个浏览器进程基础包括：主进程（browser）、GPU进程、渲染进程、网络进程、插件进程")])]),t._v(" "),a("h3",{attrs:{id:"浏览器多进程的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器多进程的优缺点"}},[t._v("#")]),t._v(" 浏览器多进程的优缺点")]),t._v(" "),a("p",[a("strong",[t._v("优点：")])]),t._v(" "),a("ol",[a("li",[t._v("避免单个页面崩溃影响整个浏览器")]),t._v(" "),a("li",[t._v("避免第三方插件崩溃影响整个浏览器")]),t._v(" "),a("li",[t._v("多进程充分利用多核优势")]),t._v(" "),a("li",[t._v("方便使用沙盒模型隔离插件等进程，提高浏览器安全性")]),t._v(" "),a("li",[t._v("提供了用户体验")])]),t._v(" "),a("p",[t._v("**缺点：**对系统资源消耗大，因为进程是要占用内存的")]),t._v(" "),a("h2",{attrs:{id:"浏览器的进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的进程"}},[t._v("#")]),t._v(" 浏览器的进程")]),t._v(" "),a("h3",{attrs:{id:"browser进程-主进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#browser进程-主进程"}},[t._v("#")]),t._v(" browser进程（主进程）")]),t._v(" "),a("p",[t._v("主进程只有一个，是浏览器的核心，他提供以下功能：")]),t._v(" "),a("ol",[a("li",[t._v("负责浏览器界面显示，与用户交互的前进后退等。")]),t._v(" "),a("li",[t._v("负责各个页面的管理，创建和销毁其他进程。")]),t._v(" "),a("li",[t._v("将渲染线得到的内存中的位图渲染到用户界面上。")]),t._v(" "),a("li",[t._v("网络资源的管理，下载。")])]),t._v(" "),a("h3",{attrs:{id:"插件进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件进程"}},[t._v("#")]),t._v(" 插件进程")]),t._v(" "),a("p",[t._v("插件进程有多个，因为插件容易崩溃的问题所以一般会对其进行隔离，以确保不会对浏览器和页面造成影响")]),t._v(" "),a("p",[t._v("每种类型的插件对应一个进程，仅当使用该插件时才会创建。")]),t._v(" "),a("h3",{attrs:{id:"gpu进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gpu进程"}},[t._v("#")]),t._v(" GPU进程")]),t._v(" "),a("p",[t._v("GPU也只有一个，用户3D绘制，仅当页面使用了硬件加速才会使用它来渲染页面，否侧使用browser进程来渲染页面。")]),t._v(" "),a("h3",{attrs:{id:"渲染进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程"}},[t._v("#")]),t._v(" 渲染进程")]),t._v(" "),a("p",[t._v("每个tab页面都会有自己的渲染进程，各自互不影响，用来渲染页面，进行脚本执行等。")]),t._v(" "),a("p",[t._v("渲染进程包括：界面渲染线程、js引擎现场、浏览器事件处理线程、http请求现场")]),t._v(" "),a("h4",{attrs:{id:"界面渲染线程-gui"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#界面渲染线程-gui"}},[t._v("#")]),t._v(" 界面渲染线程（GUI）")]),t._v(" "),a("p",[t._v("负责渲染浏览器界面，解析html，css，建立dom树等，包括回流重绘这些也是在这里。")]),t._v(" "),a("h4",{attrs:{id:"js引擎线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js引擎线程"}},[t._v("#")]),t._v(" JS引擎线程")]),t._v(" "),a("p",[t._v("负责解析js脚本，运行js代码，tab页只允许存在一个js线程")]),t._v(" "),a("p",[t._v("GUI渲染进程和JS引擎进程是互斥关系，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎闲置下来后立即执行。也就说，当JS执行时间过长时会导致页面的渲染被阻塞。")]),t._v(" "),a("h3",{attrs:{id:"事件触发线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件触发线程"}},[t._v("#")]),t._v(" 事件触发线程")]),t._v(" "),a("p",[t._v("时间触发线程也就是我们的任务队列。")]),t._v(" "),a("p",[t._v("对浏览器里面的操作事件响应。")]),t._v(" "),a("p",[t._v("例如监听鼠标和键盘等事件时，如果有对应事件处理函数会将其压入任务队列，等待js引擎处理。")]),t._v(" "),a("h4",{attrs:{id:"http请求线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http请求线程"}},[t._v("#")]),t._v(" http请求线程")]),t._v(" "),a("p",[t._v("当执行一个http异步请求时，就把异步请求事件添加到异步请求队列线程，等收到响应再把毁掉函数添加到事件队列，等待js引擎来执行")]),t._v(" "),a("h4",{attrs:{id:"定时器线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时器线程"}},[t._v("#")]),t._v(" 定时器线程")]),t._v(" "),a("p",[t._v("指的便是我们常用等setInternal和setTimeout")]),t._v(" "),a("p",[t._v("看到这里就可以知道，setInternal和setTimeout并不是JavaScript引擎的，而是通过单独的线程来计时进行触发，将回调函数加入到事件队列")]),t._v(" "),a("h3",{attrs:{id:"网络进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络进程"}},[t._v("#")]),t._v(" 网络进程")]),t._v(" "),a("p",[t._v("主要负责页面的网络资源加载，一切时作为模块运行在浏览器进程中，后来被独立出去")]),t._v(" "),a("h2",{attrs:{id:"事件循环机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环机制"}},[t._v("#")]),t._v(" 事件循环机制")]),t._v(" "),a("p",[t._v("了解了上面的线程之后是不是可以对事件循环有新的理解了呢？总结一下")]),t._v(" "),a("p",[t._v("js任务队列理论可以分为两种，同步任务和异步任务。")]),t._v(" "),a("p",[t._v("举个例子。")]),t._v(" "),a("ol",[a("li",[t._v("同步任务会在主线程（js引擎线程）上执行，形成一个执行栈")]),t._v(" "),a("li",[t._v("主线程外，http请求线程/定时器线程这两个线程的异步任务有了结果后将事件回调加入到事件队列，事件触发线程再将处理好的回调函数加入到任务队列，也就是宏任务队列")]),t._v(" "),a("li",[t._v("执行栈所有同步事件执行完了之后系统会读取微任务队列执行，等到微任务也执行完了之后，就会从我们的任务队列中取出一个，将可以运行的异步任务回调加到执行栈开始执行。")]),t._v(" "),a("li",[t._v("不断循环走上面三步，就是我们所说的事件循环了。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);