(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{392:function(t,a,s){"use strict";s.r(a);var e=s(11),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javascript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[t._v("#")]),t._v(" JavaScript")]),t._v(" "),a("h2",{attrs:{id:"基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),a("h3",{attrs:{id:"改变-this-指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#改变-this-指针"}},[t._v("#")]),t._v(" 改变 this 指针")]),t._v(" "),a("p",[t._v("原生 js 改变 this 指针的方法一共有三种：bind、apply、call")]),t._v(" "),a("h4",{attrs:{id:"使用方法-xx-bind-、xx-apply-、xx-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用方法-xx-bind-、xx-apply-、xx-call"}},[t._v("#")]),t._v(" **使用方法：**xx.bind()()、xx.apply()、xx.call()")]),t._v(" "),a("h4",{attrs:{id:"使用方法区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用方法区别"}},[t._v("#")]),t._v(" "),a("strong",[t._v("使用方法区别：")])]),t._v(" "),a("ol",[a("li",[t._v("apply 和 call 使用时会直接执行函数，而 bind 不会直接，需要直接再加个()调用")]),t._v(" "),a("li",[t._v("apply 的第二个参数支持数组，而 call 不支持")])]),t._v(" "),a("h4",{attrs:{id:"使用状况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用状况"}},[t._v("#")]),t._v(" "),a("strong",[t._v("使用状况：")])]),t._v(" "),a("ul",[a("li",[t._v("bind 适用在改变 this 指针后不直接执行函数的情况")]),t._v(" "),a("li",[t._v("call 适用在传参较少的情况、而 apply 则适用在传参多的情况下，也就是数组的时候")])]),t._v(" "),a("h4",{attrs:{id:"经典用例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#经典用例"}},[t._v("#")]),t._v(" "),a("strong",[t._v("经典用例：")])]),t._v(" "),a("p",[t._v("求一个数组中最小的值：Math.min.apply(this,arr)，求最大值同理")]),t._v(" "),a("p",[t._v("合并两个数组：Array.prototype.push.apply(arr1,arr2)")]),t._v(" "),a("h3",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("p",[a("strong",[t._v("提问：什么是闭包？")])]),t._v(" "),a("p",[t._v("答：闭包其实就是 js 函数作用域的一种副产品，换句话说就是函数内部能使用函数外部的变量符合了闭包的这种定义。")]),t._v(" "),a("p",[a("strong",[t._v("提问：闭包的作用？")])]),t._v(" "),a("p",[t._v("答：当你要隐藏一个变量，将一个变量藏在某处，不让人随意看见和操作，这时你可以改用一个函数来操作隐藏起来的作用，以达到封闭变量的要求")]),t._v(" "),a("h3",{attrs:{id:"promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),a("p",[a("strong",[t._v("提问：有关 js 的异步操作你知道什么？")])]),t._v(" "),a("p",[t._v("答：JavaScript 中有一个 promise，作用是解决 js 中的回调地狱和异步操作没有先后顺序的问题")]),t._v(" "),a("p",[a("strong",[t._v("提问：什么是回调地狱？")])]),t._v(" "),a("p",[t._v("答：在执行一些异步操作时，需要把函数作为返回值，这样嵌套太多后就会形成回调地狱，难以分清哪是哪个函数")]),t._v(" "),a("p",[a("strong",[t._v("提问：promise 实现的方法与原理")])]),t._v(" "),a("p",[t._v("答：原理其实也没什么，就是把要异步执行的函数 new 成一个 promise 对象，然后这个 promise 对象有 then 和 catch 两个函数，分别可以用来执行函数进行成功与失败的处理")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("promise")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("reject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 就像回调函数，括号内的值会返回给then\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  同理，不过他通常是用来处理错误的情况\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("h2",{attrs:{id:"es6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[t._v("#")]),t._v(" es6")]),t._v(" "),a("h3",{attrs:{id:"提问-es6-想比-es5-新增了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提问-es6-想比-es5-新增了什么"}},[t._v("#")]),t._v(" 提问：es6 想比 es5 新增了什么？")]),t._v(" "),a("p",[t._v("答：")]),t._v(" "),a("ol",[a("li",[t._v("新增 let 和 const 两种块级变量声明，es5 没有块级作用域一说。原先 var 有变量提升，新增的没有。")]),t._v(" "),a("li",[t._v("箭头函数，并且箭头函数不是构造函数，不能用 new 使用，this 跟随上下文，无法用 call 或 apply 等方法修改 this。")]),t._v(" "),a("li",[t._v("新增反引号增强版字符串，即可以像普通字符串使用，也可以用来定义多行字符串。")]),t._v(" "),a("li",[t._v("解构赋值，有对象解构和数组解构")]),t._v(" "),a("li",[t._v("for...of 和 for...in，分别可以用来遍历数组和对象，set 和 map 关系容器（会自动排序，不允许重复键）")]),t._v(" "),a("li",[t._v("import 和 export 导入和导出新概念，从此有了模块化功能")]),t._v(" "),a("li",[t._v("展开运算符...，可以将数组或对象的值展开，还可以将多个值收集为一个变量")]),t._v(" "),a("li",[t._v("引入 class 的继承方式，而不是用原型链方式继承（class 对转前端的人语法糖）")]),t._v(" "),a("li",[t._v("promise、async/await")]),t._v(" "),a("li",[t._v("symbol，唯一值，不可修改")]),t._v(" "),a("li",[t._v("proxy")]),t._v(" "),a("li",[t._v("Reflect，是 es6 为操作对象新增的 api，将 object 对象一些明显的语言内部方法放在 reflect 里面，用时就可以直接用 reflect 使用内部方法。（ 在使用对象的 Object.defineProperty(obj, name, {})时，如果出现异常的话，会抛出一个错误，需要使用 try catch 去捕获，但是使用 Reflect.defineProperty(obj, name, desc) 则会返回 false。 ）")])]),t._v(" "),a("h1",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" vue")]),t._v(" "),a("h2",{attrs:{id:"基础-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础-2"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),a("h3",{attrs:{id:"diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[t._v("#")]),t._v(" diff 算法")]),t._v(" "),a("p",[t._v("vue 中会对整个 list 进行遍历, 判断使用到的某些属性是否发生变更, 从而更新发生变更的 item\n所以 key 属性才会显得很重要, 它会告诉你, 我那个 item 发生变更, 而不是去检测整个 list")]),t._v(" "),a("h3",{attrs:{id:"key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#key"}},[t._v("#")]),t._v(" key")]),t._v(" "),a("ol",[a("li",[t._v("更高效的更新虚拟 dom（update 的时候会有一个虚拟 dom）。因为 vue 内的渲染是有个 diff 算法的，在 patch 的过程会判断两个两节是否一致，这样就可以避免频繁更新不同元素")]),t._v(" "),a("li",[t._v("解决一些隐藏 bug（像是不加 key 会报错之类的）")]),t._v(" "),a("li",[t._v("vue 有个过渡属性，在过渡的时候如果相同元素没有不同的 key 会导致只替换了内部属性而不会触发过渡效果")])]),t._v(" "),a("h2",{attrs:{id:"路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[t._v("#")]),t._v(" 路由")]),t._v(" "),a("h3",{attrs:{id:"hash-和-history-模式的不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-和-history-模式的不同"}},[t._v("#")]),t._v(" hash 和 history 模式的不同")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("hash 会带有#，而 history 不会带有")])]),t._v(" "),a("li",[a("p",[t._v("hash 只能修改#后面部分，且只能设置与当前 url 相同文档的 url。history 只要是同源的都可。")])]),t._v(" "),a("li",[a("p",[t._v("url 更改时 hash 不会记录记录更新前后相同的 url 记录；history 会")])]),t._v(" "),a("li",[a("p",[t._v("history 能传任意类型的参数，hash 不行")])]),t._v(" "),a("li",[a("p",[t._v("history 不仅可以在 url 内传参，还可以将数据存放在特定对象内（比如 pushState(state)内的 state 就是）")])]),t._v(" "),a("li",[a("p",[t._v("hash 只将#前的内容包含在请求中，所以就算没有路由全覆盖也不会出现 404 状况。history 跟传统的页面请求一样，整个 url 会向服务器发起请求，未发现则会 404")])]),t._v(" "),a("li",[a("p",[t._v("hash 本质是修改页面数据，就像 ajax 那样，而 history 是更新页面")])]),t._v(" "),a("li",[a("p",[t._v("hash 模式的原理是路由发生改变时会触发 onhashonchange 事件，用 window.addEventListener 监听这个事件，hash 值不会传到后台，因此服务器只需做一个根地址的映射即可。")])]),t._v(" "),a("li",[a("p",[t._v("history 理由 html5 history interface 新增的 pushState 和 replaceState，用来更新历史记录栈，并且不会后端发送请求。")])])]),t._v(" "),a("h3",{attrs:{id:"query-和-parmas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#query-和-parmas"}},[t._v("#")]),t._v(" query 和 parmas")]),t._v(" "),a("ol",[a("li",[t._v("query 只能用 path 来引入路由（但是实测 query 无论是 path 还是 name 都可以），而不是 name，params 相反")]),t._v(" "),a("li",[t._v("params 是路由的一部分,必须要在路由后面添加参数名。query 是拼接在 url 后面的参数，没有也没关系。")]),t._v(" "),a("li",[t._v("query 类似 ajax 的 get 请求，参数会显示在 url 上；params 类似于 post，参数不会显示在 url")])]),t._v(" "),a("h2",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("h3",{attrs:{id:"beforecraete"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforecraete"}},[t._v("#")]),t._v(" beforeCraete")]),t._v(" "),a("p",[t._v("el 和 data 都没有。一般不做操作")]),t._v(" "),a("h3",{attrs:{id:"craeted"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#craeted"}},[t._v("#")]),t._v(" craeted")]),t._v(" "),a("p",[t._v("el 没有，data、computed、watch 有了，这里修改数据不会触发 updated。一般用来初始化数据的获取")]),t._v(" "),a("h3",{attrs:{id:"beforemount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforemount"}},[t._v("#")]),t._v(" beforeMount")]),t._v(" "),a("p",[t._v("首次调用渲染函数 render，一般用来初始化数据的获取")]),t._v(" "),a("h3",{attrs:{id:"mounted"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mounted"}},[t._v("#")]),t._v(" mounted")]),t._v(" "),a("p",[t._v("el 和 data 都有。可以进行真实的 dom 操作")]),t._v(" "),a("h3",{attrs:{id:"beforeupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforeupdate"}},[t._v("#")]),t._v(" beforeUpdate")]),t._v(" "),a("p",[t._v("数据要更新了，被调用。一般不做什么事。")]),t._v(" "),a("h3",{attrs:{id:"updated"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updated"}},[t._v("#")]),t._v(" updated")]),t._v(" "),a("p",[t._v("虚拟 dom 重新渲染补丁，以最小 dom 开支来重新渲染 dom。这里一般不做什么操作（唯一能想到的应用场合是实时聊天的自动滚动下滑）")]),t._v(" "),a("h3",{attrs:{id:"beforedestroy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforedestroy"}},[t._v("#")]),t._v(" beforeDestroy")]),t._v(" "),a("p",[t._v("data 还有，el 没了。这里一般用做一些善后工具，例如清楚定时器，非指令绑定的事件")]),t._v(" "),a("h3",{attrs:{id:"destroyed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#destroyed"}},[t._v("#")]),t._v(" destroyed")]),t._v(" "),a("p",[t._v("watcher、子组件等事件监听器都没了。这里只有 dom 的空壳，也可以用来善后")]),t._v(" "),a("h2",{attrs:{id:"内置方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内置方法"}},[t._v("#")]),t._v(" 内置方法")]),t._v(" "),a("p",[t._v("生产顺序：porps=>methods=>data=>computed>watch")]),t._v(" "),a("h3",{attrs:{id:"computed-和-watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch"}},[t._v("#")]),t._v(" computed 和 watch")]),t._v(" "),a("ol",[a("li",[t._v("如果一个数据依赖于其他数据，那么使用 computed；如果需要在一个数据变化时做一些事情，那么使用 watch 更合适。")]),t._v(" "),a("li",[t._v("computed 会有缓存，watch 没有")]),t._v(" "),a("li",[t._v("computed 不支持异步，watch 支持")]),t._v(" "),a("li",[t._v("computed 的属性是一对一或一对多，而 watch 是一对多")])]),t._v(" "),a("h2",{attrs:{id:"组件间的值传递"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件间的值传递"}},[t._v("#")]),t._v(" 组件间的值传递")]),t._v(" "),a("h3",{attrs:{id:"父子传递"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父子传递"}},[t._v("#")]),t._v(" 父子传递")]),t._v(" "),a("p",[t._v("父组件向子组件传递用 props，子向父传递用$emit")]),t._v(" "),a("h3",{attrs:{id:"兄弟传递"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#兄弟传递"}},[t._v("#")]),t._v(" 兄弟传递")]),t._v(" "),a("ol",[a("li",[t._v("创建一个共用的 js 文件（在 js 内导出 vue 的实例），在需要传值的组件内导入，通过$emit触发方法，用$on 来响应触发（列如在 a 文件内用$emit触发一个方法（此时可传参），而在b用$on('aa')来响应触发。）")]),t._v(" "),a("li",[t._v("在 vue 实例的原型对象内添加另一个 vue 实例，这样就可以直接用 this.$xxx 操作了")])]),t._v(" "),a("h2",{attrs:{id:"vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" Vuex")]),t._v(" "),a("p",[t._v("提示：在面试官问的时候，尽量把小项目没必要用 vuex 记在脑子里！")]),t._v(" "),a("p",[a("strong",[t._v("问：vuex 由哪些部分组成")]),t._v("/")]),t._v(" "),a("p",[t._v("答：State、Getters、Mutations、Actions、Modules")]),t._v(" "),a("p",[a("strong",[t._v("问：能更具体解释一下这五个部分吗？")])]),t._v(" "),a("p",[t._v("答：State 对应 vue 内的 data、Getters 对应 vue 中 computed 的获取、Muations 和 Actions 对应 vue 内的 methods、modules 就是把 store 模块化，以防有方法名或者 state 名中途之类的。")]),t._v(" "),a("p",[a("strong",[t._v("问：State 的特性是？")])]),t._v(" "),a("p",[t._v("一、Vuex 就是一个仓库，仓库里面放了很多对象。其中 state 就是数据源存放地，对应于与一般 Vue 对象里面的 data\n二、state 里面存放的数据是响应式的，Vue 组件从 store 中读取数据，若是 store 中的数据发生改变，依赖这个数据的组件也会发生更新\n三、它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性中")]),t._v(" "),a("p",[a("strong",[t._v("问：Getter 特性是？")]),t._v("\n一、getters 可以对 State 进行计算操作，它就是 Store 的计算属性\n二、 虽然在组件内也可以做计算属性，但是 getters 可以在多组件之间复用\n三、 如果一个状态只在一个组件内使用，是可以不用 getters")]),t._v(" "),a("p",[a("strong",[t._v("问：muation 和 actions 的关系？")])]),t._v(" "),a("p",[t._v("一、actions 跟 mutations 相同，但 actions 支持异步，mutations 不支持，原因是 actions 默认会自封装一个 Promise")]),t._v(" "),a("p",[t._v("二、actions 用来提交 mutations，而不是直接变更状态")]),t._v(" "),a("p",[t._v("三、mutations 是通过 commit 改变数据")]),t._v(" "),a("p",[a("strong",[t._v("问：不用 Vuex 会带来什么问题？")])]),t._v(" "),a("p",[t._v("一、可维护性会下降，你要想修改数据，你得维护三个地方")]),t._v(" "),a("p",[t._v("二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的")]),t._v(" "),a("p",[t._v("三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。")]),t._v(" "),a("p",[t._v("但兄弟组件有大量通信的，建议一定要用，不管大项目和小项目，因为这样会省很多事")]),t._v(" "),a("h2",{attrs:{id:"vue3-面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-面试题"}},[t._v("#")]),t._v(" Vue3 面试题")]),t._v(" "),a("h3",{attrs:{id:"提问-vue3-有什么新特性【-】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提问-vue3-有什么新特性【-】"}},[t._v("#")]),t._v(" 提问：vue3 有什么新特性【？】")]),t._v(" "),a("ol",[a("li",[t._v("响应式变动，原本 vue2 用的是 getter 和 setter，现在改成了 es2015 的 proxy 代理观察机制。消除了原本的警告，速度加倍，节省了一半的内存开销。")]),t._v(" "),a("li",[t._v("虚拟 dom 的重写。节省 vue 执行时的开销。")]),t._v(" "),a("li",[t._v("组件渲染得到优化。vue2 的父组件渲染同时会连子组件一起渲染，vue3 就是单独渲染父组件和子组件了。")]),t._v(" "),a("li",[t._v("静态树的提升。vue3 会检测哪些是静态组件，然后将其提升，从而降低渲染成本。")]),t._v(" "),a("li",[t._v("是用来 proxy，抛弃原本的 Object.defineProperty()，不需要重载数组，省去很多 hack，减少代码量等同于减少维护成本")]),t._v(" "),a("li",[t._v("vue2 为什么不用 proxy？兼容性，在 es2015 时 proxy 才正式被规范。")]),t._v(" "),a("li",[t._v("diff 算法优化，事件监听有缓存，静态提升 hoistStatic")])]),t._v(" "),a("h3",{attrs:{id:"提问-vue3-和-vue2-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提问-vue3-和-vue2-的区别"}},[t._v("#")]),t._v(" 提问：vue3 和 vue2 的区别？")]),t._v(" "),a("ol",[a("li",[t._v("setup()可取代 data 和 methods 的一些功能，目的是使用组合式 api，setup 中没 this，在 beforeCreate 前调用")])]),t._v(" "),a("p",[t._v("​")])])}),[],!1,null,null,null);a.default=r.exports}}]);